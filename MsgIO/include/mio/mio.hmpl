#pragma once

#include "functional.h"
#include "unwindows.h"
#include "memory.h"

namespace mio {

class basic_handler;
class handler;
class event;

typedef shared_ptr<basic_handler> shared_handler;
typedef weak_ptr<basic_handler> weak_handler;

class loop 
{
private: //Disable copy and assignment
	loop(const loop&);         
	void operator=(const loop&);

public:
    loop();
    ~loop();

    void start(int num);

    void run(int num);   // run = start + join

    bool is_running() const;

    void end();
    bool is_end() const;

    void join();

    void remove_handler(int fd);

    typedef function<void (int fd, int err)> connect_callback_t;

    void connect(
        int socket_family, int socket_type, int protocol,
        const sockaddr* addr, int addrlen,
        double timeout_sec, connect_callback_t callback);


    typedef function<void (int fd, int err)> listen_callback_t;

    int listen(
        int socket_family, int socket_type, int protocol,
        const sockaddr* addr, int addrlen,
        listen_callback_t callback,
        int backlog = 1024);

    int add_timer(double value_sec, double interval_sec,
        function<bool ()> callback);

    void remove_timer(int ident);
    
    typedef void (*finalize_t)(void* user);

	void write(int fd, const void* buf, size_t size);

	void write(int fd, const void* buf, size_t size,
			finalize_t fin, void* user);

    template <typename Handler>
    shared_ptr<Handler> add_handler();
    %varlen_each do |gen|
        template <typename Handler, [%gen.template%]>
    shared_ptr<Handler> add_handler([%gen.args%]);
    %end


	template <typename F>
    void submit(F f);
    %varlen_each do |gen|
        template <typename F, [%gen.template%]>
    void submit(F f, [%gen.args%]);
    %end

private:
    shared_handler add_handler_impl(shared_handler sh);

    typedef function<void ()> task_t;
    void submit_impl(task_t f);

private:
    void *_impl;
};

class event 
{
private: //Disable copy and assignment
    event(const event&);         
    void operator=(const event&);

public:
    event(){};
};

class basic_handler 
{
private: //Disable copy and assignment
    basic_handler(const basic_handler&);         
    void operator=(const basic_handler&);
    basic_handler();

public:
    typedef bool (*callback_t)(basic_handler*, event&);

    template <typename IMPL>
    basic_handler(int ident, IMPL* self) :
    m_ident(ident), m_callback(&static_callback<IMPL>) { }

    basic_handler(int ident, callback_t callback) :
    m_ident(ident), m_callback(callback) { }

    virtual ~basic_handler() { }

    int ident() const { return m_ident; }

    int fd() const { return ident(); }

    bool operator() (event& e);

private:
    int m_ident;

    callback_t m_callback;

private:
    template <typename IMPL>
    static bool static_callback(basic_handler* self, event& e)
    {
        return (*static_cast<IMPL*>(self))(e);
    }
};


class handler : public mio::enable_shared_from_this<handler>, public basic_handler {
public:
    handler(int fd) : basic_handler(fd, &callback_on_read) { }

    ~handler() { ::closesocket(fd()); }

    virtual void on_read(event& e) = 0;

public:
    template <typename IMPL>
    shared_ptr<IMPL> shared_self()
    {
        return static_pointer_cast<IMPL>(enable_shared_from_this<handler>::shared_from_this());
    }

    template <typename IMPL>
    shared_ptr<IMPL const> shared_self() const
    {
        return static_pointer_cast<IMPL>(enable_shared_from_this<handler>::shared_from_this());
    }

private:
    static inline bool callback_on_read(basic_handler* self, event& e)
    {
        static_cast<handler*>(self)->on_read(e);
        return true;
    }
    friend class basic_handler;
};


inline bool basic_handler::operator() (event& e)
{
    if(m_callback == handler::callback_on_read) {
        return handler::callback_on_read(this, e);
    } else {
        return m_callback(this, e);
    }
}

template <typename Handler>
shared_ptr<Handler> loop::add_handler()
{ return static_pointer_cast<Handler>(add_handler_impl(
                                      shared_ptr<Handler>(new Handler())) ); }
%varlen_each do |gen|
template <typename Handler, [%gen.template%]>
shared_ptr<Handler> loop::add_handler([%gen.args%])
{ return static_pointer_cast<Handler>(add_handler_impl(
                                      shared_ptr<Handler>(new Handler([%gen.params%]))) ); }
%end

template <typename F>
inline void loop::submit(F f)
{ submit_impl(task_t(f)); }
%varlen_each do |gen|
template <typename F, [%gen.template%]>
inline void loop::submit(F f, [%gen.args%])
{ submit_impl(bind(f, [%gen.params%])); }
%end

} // namespace mio